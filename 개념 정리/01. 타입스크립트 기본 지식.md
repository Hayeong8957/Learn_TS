# 기본 지식

## 메인 룰

- **TypeScript는 최종적으로 JavaScript로 변환**된다. 순전한 TypeScript코드를 돌릴 수 있는 것은 deno이나 대중화되지가 않았음. 브라우저, 노드는 모두 js파일을 실행한다.
- **TypeScript는 언어이자 컴파일러(tsc)이다.** 컴파일러는 ts코드를 js로 바꿔준다.
- **tsc는 tsconfig.json(`tsc --init` 시 생성)에 따라 ts 코드를 js(tsc 시 생성)로 바꿔준다.** 인풋인 ts와 아웃풋인 js 모두에 영향을 끼치므로 tsconfig.json 설정을 반드시 봐야한다.
  - 단순히 타입 검사만 하고 싶다면 **`tsc --noEmit`** 하면 된다.
  - 개인 의견: tsconfig.json에서 그냥 **`exModuleInterop: true, strict: true`** 두 개만 주로 켜놓는 편. `strict: true`가 핵심임
  - `allowJs: true` -> Javascript랑 TypeScript를 둘 다 쓸 수 있다.
  - `"target": "es2016"` -> 우리의 코드를 es6로 바꿔준다.
  - `"module": "commonJs"` -> NodeJS exprots 시스템을 사용하고 싶으면 이렇게 작성.
  - `"forceConsistentCasingInFileNames": true,` -> import해올 때 대소문자 꼭 지켜서 import 해오게
  - `"skipLibCheck": true` -> 다른 패키지들 다운 받아 사용할 때(.d.ts) 그런 패키지들 타입 컴파일 건너뛰게
- ts 파일을 실행하는 게 아니라 결과물인 js를 실행해야 한다.
- 에디터가 필수가 됨. VS code나 웹스톰 반드시 필요. 메모장으로 코딩 불가능한 지경에 이름.

## ts 문법

- 기본적으로 변수, 속성, 매개변수, 리턴값에 타입이 붙었다고 생각하면 됨.
- 타입들이 지워져도 잘 돌아가는 올바른 자바스크립트 문법이어야한다.

```typescript
const a: number = 5;
function add(x: number, y: number): number {
  return x + y;
}
const add: (x: number, y: number) => number = (x, y) => x + y;
const obj: { lat: number; lon: number } = { lat: 37.5, lon: 127.5 };
```

- string과 String은 다름. 소문자로 하는 것 기억하기

```typescript
const a: string = 'hello';
const b: String = 'hell';
```

- 특수한 타입 {} (null과 undefined가 아닌 모든 타입)

```typescript
const z: {} = 5;
```

- ts가 추론해주는 타입이 있는데 이런건 그냥 그대로 사용하면 됨. ts가 추론하지 못하는 경우에만 직접 타이핑할 것.
- 타입은 최대한 정확하게 하는 것이 중요하다. 추론이 정확하면 추론에 맡기고 타입은 최대한 좁게 정할 것.

```typescript
const a = 5; // 5라고 타입 추론하고 있는 것을 건드려 굳이 number라는 타입으로 더 부정확하게 만들 필요가 없다는 뜻
const b = '3';
const c = a + b;
function add(x: number, y: number) {
  return x + y;
}
```

- 타입 자리에 아예 고정된 원시값을 넣을 수 있음
- const는 바뀔 일이 없는데, 굳이 타입을 정할 필요가 없음. 타입을 최대한 정확하게 잡는 것이 좋음

```typescript
const f: 5 = 5;
const g: true = true;
const h: false = ture; /* 에러남 */
```

- function과 화살표 함수의 타입 선언 시 차이점을 숙지할 것

```typescript
function add1(x: number, y: number): number {
  return x + y;
} // fuction 일 때는 : 뒤에 타입이 나옴
const add2: (x: number, y: number) => number = (x, y) => x + y; // 화살표 함수 일 떄는 => 뒤에 타입이 나옴
```

- : 뒷부분, as 뒷부분, <> 부분, interface, type, function 일부를 제외하면 자바스크립트와 동일. 제외하고 생각하는 연습을 초반에 해야 함

```typescript
const obj: { lat: number; lon: number } = { lat: 37.5, lon: 127.5 };
const obj = { lat: 37.5, lon: 127.5 };

const a = document.querySelector('#root') as HTMLDivElement;
const a = document.querySelector('#root');

function add<T>(x: T, y: T): T {
  return x + y;
}
function add(x, y) {
  return x + y;
}

interface A {}
type A = {};
```

- 함수 type alias 하는 방법

```typescript
type Add3 = (x: number, y: number) => number;
const add3: Add3 = (x, y) => x + y;

/* 함수 type interface */
interface Add4 {
  (x: number, y: number): number;
}
const add4: Add4 = (x, y) => x + y;
```

- 자바스크립트에 비해서 자유도가 확 줄어듦(ex: 변수에 문자열을 넣었다가 숫자로 바꾸는 등의 행동 어려워짐)

```typescript
let x = 5;
x = 'hello';
```

- any를 최대한 쓰지 않는 것을 목표로 할 것.
- never, unknown, any 타입 주의하기. any는 최대한 피하고 쓰더라도 나중에 꼭 제대로 타이핑하기.
- [never 설명글](https://ui.toast.com/weekly-pick/ko_20220323)
- 빈배열을 조심하라 -> never[]라는 타입이 들어옴
  - never라는 타입이 뜨면 일반적인 타입을 넣을 수 없다.
  - 따라서 타이핑 지정을 무조건 해줘야함

```typescript
try {
  const array = []; // noImplicitAny가 false일 때
  array[0];
} catch (error) {
  error;
}
```

- 최대한 !대신 if를 쓸 것
  - ! : null이나 undefined가 아님을 보증하는 방식
  - 보통 TypeScript는 element | null로 타입을 잡아줌 -> 모든 가능성을 고려해줌 -> 만약 head가 있는 것이 무조건 확실하다 싶으면 뒤에 느낌표를 넣으면 된다.
  - **근데 사실 비추 -> 이 세상에 "절대"는 없다.**

```typescript
const head = document.querySelector('#head')!; // 비추
console.log(head);

const head = document.querySelector('#head');
if (head) {
  // head
  console.log(head);
}
```

- string과 String은 다름. 소문자로 하는 것 기억하기
- String은 래퍼 개체이다. String은 언제 쓰냐면 new String();으로 쓸 때 사용한다. 그러나 실제로 잘 사용하지 않음.

```typescript
const a: string = 'hello';
const b: String = 'hell';
```

![image](https://github.com/Hayeong8957/Learn_TS/assets/70371342/38fd3559-c312-4e72-ae77-aaae5c19fb34)

- 템플릿 리터럴 타입이 존재(유니언 등 사용 가능)
- 템플릿 리터럴 변수에 타입 넣어도 됨. 타입의 값이 그대로 들어가게 됨.

```typescript
type World = 'world' | 'hell';

//type Greeting = 'hello world'
type Greeting = 'hello ${World}'; // -> 'hello world'

// 현실적인 응용법은 다음과 같다.
const a: Greeting = 'hello world'; // 이 시점에서 타입을 정교하게 추론해줌
```

- `type World = ‘world’ | ‘hell’ ;` union으로 두 타입으로 지정이 되었고, 템플릿 리터럴 타입을 선언하고(Greeting), 해당 템플릿 리터럴 타입을 타입으로 지정했을 경우, 타입을 정교하게 추천해준다.
  ![image](https://github.com/Hayeong8957/Learn_TS/assets/70371342/ec226a6c-7226-48ee-816b-b62c14bc7beb)

- 배열, rest, 튜플 문법

```typescript
/* 배열 타입 */
let arr: string[] = [];
let arr2: Array<string> = [];

/* rest 타입 */
function rest(...args: string[]) {}

function rest(...args: string[]) {
  console.log(args); // ["1", "2", "3"]
}

rest('1', '2', '3');

function rest2(a: number, ...args: string[]) {
  console.log(a, args); // 1, ["1", "2", "3"]
}

rest2(1, '1', '2', '3');

/* 튜플 */
const tuple: [string, number] = ['1', 1]; // 타입 요소 갯수가 정해져 있으면
tuple[2] = 'hello'; // 이렇게 넣었을 때 에러가 남 -> 현재 튜플 요소는 2개밖에 없는데 3번째 요소에 넣으려고 하다보니 에러가 남
tuple.push('hello'); // 튜플인데 push가 가능함 -> 위에 코드로 요소를 넣는 건 안되는데, 현재 코드로 push해서 3번째 요소에 넣는 건 에러메세지가 안남 (사소한 오류)
```

- enum, keyof, typeof
- enum : 여러개의 변수들을 하나로 묶고 싶을 때 사용 -> 개인적으로 일반 객체 씀(by. 제로초)
- keyof : 객체의 키들만 꺼내오고 싶을 때 사용
- typeof : 값을 타입으로 쓰고 싶을 때 사용

```typescript
const enum EDirection {
  Up,
  Down,
  Left,
  Right,
}
// enum은 자바스크립트에서 사라짐 -> 안남아있게 하고 싶다. -> enum 사용

const ODirection = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
};
// -> 현재는 추론이 다 number로 되어있음

// as const 를 붙이면 난 이 속성들을 상수로 쓰겠다 -> 정확하게 타이핑해줌. -> readonly까지 정확하게 고정
const ODirection = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
} as const;
// 객체는 자바스크립트에 남아있음 -> 남아있게 하고 싶다. -> 객체 사용
// 남겨야할지 안 남겨야할지 고민 -> 남기는 걸 추천

EDirection.Up;

(enum member) EDirection.Up = 0

ODirection.Up;

(property) Up: 0

// Using the enum as a parameter
// enum은 직접 타입으로도 쓸 수 있다.
function walk(dir: EDirection) {} // dir은 4개중(Up, Down, Left, Right) 하나여야 한다.

// It requires an extra line to pull out the keys
type Direction = typeof ODirection[keyof typeof ODirection];
function run(dir: Direction) {}

const obj = {a: '123', b: 'hello', c: 'world'} as const;
// 객체의 키값만 가져와 타입으로 설정
type Key = keyof typeof obj;              // type Key = "a" | "b" | "c"
// 객체의 값만 가져와 타입으로 설정
type Key2 = typeof obj[keyof typeof obj]; // type Key2 = "123" | "hello" | "world"
// obj는 자바스크립트 값임 -> 자바스크립트 값은 타입으로 쓸 수 없음 -> 타입으로 쓰고 싶으면 typeof를 붙여줌 -> 거기에 keyof를 하면 "a", "b", "c"를 뽑아낸다. -> 그리고 그걸 Key라는 타입으로 만듦

walk(EDirection.Left); // function walk(dir: EDirection) {}
run(ODirection.Right); // function run(dir: Direction): void
```

- 객체 타이핑: type과 interface 구분하기
- 둘 중에 뭐가 낫냐하면 간단하게 하고 싶으면 type을 쓰고, interface는 상속과 구현하는 개념이 포함되어있음 -> 나중에 객체지향 프로그래밍을 하고 싶으면 interface를 사용하는 것이 좋음.
  - type으로도 객체지향 구현이 가능하나, interface문법이 문법적으로 지원을 많이 해줌.
    [interface vs type 비교](https://yceffort.kr/2021/03/typescript-interface-vs-type)

```typescript
type A = { a: string }; // A라는 타입을 정의해서
const a: A = { a: 'hello' }; // 여기에 욱여 넣음
// const a: { a: string } = { a: 'hello' }; // 이렇게 바로 넣어도 무방

interface B {
  a: string;
}
const b: B = { a: 'hello' };
```

```typescript
type Animal = { breath: true };
type Poyouryu = Animal & { breed: true };
type Human = Poyouryu & { think: true };

const hayeong: Human = { breath: true, breed: true, think: true };

interface Animal2 {
  breath: true;
}
interface Poyouryu2 extends Animal2 {
  breed: true;
}
interface Human2 extends Poyouryu2 {
  think: true;
}
const hayeon2: Human2 = { breath: true, breed: true, think: true };

// type의 좋은 점은 간단하게 쓸 수 있고
// interface는 타입처럼 욱여넣을 수 없기 때문에 extends확장이라는 개념이 명확함
```

- union, intersection
- union(|) : 또는 -> 타입 추론이 제대로 안된다. -> 모든 경우를 다 고려하게 됨
- intersection(&) : 둘 다 -> 객체에서 사용 가능

```typescript
// error: '+' 연산자를 'string | number' 및 'string | number' 형식에 적용할 수 없습니다.ts(2365)
// typescript를 할 때 처음 type을 잘 짜놔야함, 안그러면 줄줄이 다 꼬임
function add(x: string | number, y: string | number): string | number {
  return x + y;
}
add(1, 2);
add('1', '2');
add(1, '2');

type A = {
  a: string;
};
type B = {
  b: string;
};

const abab1: A | B = { a: 'hello', b: 'world' }; // A 또는 B -> A도 만족하고 B도 만족하기에 됨 -> A와 B 둘 중에 하나만 있으면 만족
const abab2: A | B = { a: 'hello' }; // 하나를 지워도 된다.

const baba1: A & B = { a: 'hello', b: 'world' }; // A 와 B 둘 다 만족시켜야 함 -> 모든 속성이 다 있어야 함
const baba2: A & B = { a: 'hello' }; // A 와 B 둘 다 만족시켜야 함 -> error
```

- 선언적 확장 : interface끼리는 서로 합쳐짐(같은 이름으로 선언하면 타입이 합쳐짐)
- type은 새로운 속성을 추가하기 위해 다시 같은 이름으로 선언할 수 없지만, interface는 항상 선언적 확장이 가능
- 라이브러리들이 대부분 type이 아니라 interface로 만들어짐 -> 라이브러리 타입을 같은 이름으로 추가만 하면 됨

```typescript
interface A {
  a: string;
}
interface A {
  b: string;
}
const obj1: A = { a: 'hello', b: 'world' };

type B = { a: string };
type B = { b: string };
const obj2: B = { a: 'hello', b: 'world' };
```

- 타입을 집합으로 생각하자(좁은 타입과 넓은 타입)
  - 밴다이어그램으로 생각하면 쉽다는 뜻
  - 큰 타입에 작은 타입을 넣으려는 시도, 작은 타입에 큰 타입을 넣으려는 시도가 발생할 수 있다.
  - 작은 타입이란, 더 구체적인 타입을 의미

```typescript
type AAA = string | number; // 이게 더 넓은 타입 -> 합집합
type BBB = string;
// 여기서 룰은 좁 -> 넓으로 대입이 가능, 넓 -> 좁 대입 불가능
// never -> 공집합, any -> 전체집합 느낌

type BBB2 = string;
type CCC = string & number; // 이게 더 좁은 타입

// 객체는 상세할수록 타입이 좁다고 생각 -> 구체적일수록 타입이 좁음
type Aobj = { name: string };
type Bobj = { age: number };
type Cobj = { name: string; age: number };
// type Cobj = Aobj & Bobj이거랑 위의 코드랑 같음

type ABObj = Aobj | Bobj; // 합집합으로 만듦 -> 타입이 넓음

type Cobj2 = Aobj & Bobj;
const ab: ABObj = { name: 'hayeong', age: 23 };
const ab2: ABObj = { name: 'hayeong' };
const ab3: ABObj = ab; // 좁은 타입을 넓은 타입에 넣는 건 잘 됨

const c2: Cobj2 = { name: 'hayeong', age: 23 };
const c3: Cobj = ab2; // 넓은 타입을 좁은 타입에 넣으려다 보니 에러: 'age' 속성이 'Aobj' 형식에 없지만 'Cobj' 형식에서 필수입니다.ts(2741)

const c4: Cobj = { name: 'hayeong', age: 23, married: false };
// Cobj가 우항보다 더 넓은 타입인데, 에러가 나고 있다.
// error: 개체 리터럴은 알려진 속성만 지정할 수 있으며 'Cobj' 형식에 'married'이(가) 없습니다.ts(2322)
```

- 객체 리터럴은 잉여 속성 검사가 있음
- 타입에 선언된 속성 외에 속성이 있는지 체크 -> 객체 리터럴에서만 동작한다. -> 그래서 엄격한 객체 리터럴 체크라고도 불린다.

```typescript
type A = { hello: string };
const a: A = { hello: 'world', why: 'error' }; // error:  개체 리터럴은 알려진 속성만 지정할 수 있으며 'A' 형식에 'hello'이(가) 없습니다.ts(2322)

const b = { hello: 'world', why: 'error' }; // 해당 객체를 변수로 빼주고
const c: A = b; // 대입하면 에러 사라짐
```

- void 타입은 return값을 사용하지 안 겠다는 뜻(메서드나 매개변수에서는 리턴값 사용 가능, but 조심해야 함)

```typescript
declare function forEach<T>(arr: T[], callback: (el: T) => undefined): void;
// declare function forEach<T>(arr: T[], callback: (el: T) => void): void;
let target: number[] = [];
forEach([1, 2, 3], (el) => target.push(el));

interface A {
  talk: () => void;
}
const a: A = {
  talk() {
    return 3;
  },
};
```

- 타입만 선언하고 싶을 때 declare(구현은 다른 파일에 있어야 함)

```typescript
declare const a: string;
declare function a(x: number): number;
declare class A {}

// 추후 declare module, declare global, declare namespace도 배움
```
