# 기본 지식

## 메인 룰

- **TypeScript는 최종적으로 JavaScript로 변환**된다. 순전한 TypeScript코드를 돌릴 수 있는 것은 deno이나 대중화되지가 않았음. 브라우저, 노드는 모두 js파일을 실행한다.
- **TypeScript는 언어이자 컴파일러(tsc)이다.** 컴파일러는 ts코드를 js로 바꿔준다.
- **tsc는 tsconfig.json(`tsc --init` 시 생성)에 따라 ts 코드를 js(tsc 시 생성)로 바꿔준다.** 인풋인 ts와 아웃풋인 js 모두에 영향을 끼치므로 tsconfig.json 설정을 반드시 봐야한다.
  - 단순히 타입 검사만 하고 싶다면 **`tsc --noEmit`** 하면 된다.
  - 개인 의견: tsconfig.json에서 그냥 **`exModuleInterop: true, strict: true`** 두 개만 주로 켜놓는 편. `strict: true`가 핵심임
  - `allowJs: true` -> Javascript랑 TypeScript를 둘 다 쓸 수 있다.
  - `"target": "es2016"` -> 우리의 코드를 es6로 바꿔준다.
  - `"module": "commonJs"` -> NodeJS exprots 시스템을 사용하고 싶으면 이렇게 작성.
  - `"forceConsistentCasingInFileNames": true,` -> import해올 때 대소문자 꼭 지켜서 import 해오게
  - `"skipLibCheck": true` -> 다른 패키지들 다운 받아 사용할 때(.d.ts) 그런 패키지들 타입 컴파일 건너뛰게
- ts 파일을 실행하는 게 아니라 결과물인 js를 실행해야 한다.
- 에디터가 필수가 됨. VS code나 웹스톰 반드시 필요. 메모장으로 코딩 불가능한 지경에 이름.

## ts 문법

- 기본적으로 변수, 속성, 매개변수, 리턴값에 타입이 붙었다고 생각하면 됨.
- 타입들이 지워져도 잘 돌아가는 올바른 자바스크립트 문법이어야한다.

```typescript
const a: number = 5;
function add(x: number, y: number): number {
  return x + y;
}
const add: (x: number, y: number) => number = (x, y) => x + y;
const obj: { lat: number; lon: number } = { lat: 37.5, lon: 127.5 };
```

- string과 String은 다름. 소문자로 하는 것 기억하기

```typescript
const a: string = 'hello';
const b: String = 'hell';
```

- 특수한 타입 {} (null과 undefined가 아닌 모든 타입)

```typescript
const z: {} = 5;
```

- ts가 추론해주는 타입이 있는데 이런건 그냥 그대로 사용하면 됨. ts가 추론하지 못하는 경우에만 직접 타이핑할 것.
- 타입은 최대한 정확하게 하는 것이 중요하다. 추론이 정확하면 추론에 맡기고 타입은 최대한 좁게 정할 것.

```typescript
const a = 5; // 5라고 타입 추론하고 있는 것을 건드려 굳이 number라는 타입으로 더 부정확하게 만들 필요가 없다는 뜻
const b = '3';
const c = a + b;
function add(x: number, y: number) {
  return x + y;
}
```

- 타입 자리에 아예 고정된 원시값을 넣을 수 있음
- const는 바뀔 일이 없는데, 굳이 타입을 정할 필요가 없음. 타입을 최대한 정확하게 잡는 것이 좋음

```typescript
const f: 5 = 5;
const g: true = true;
const h: false = ture; /* 에러남 */
```

- function과 화살표 함수의 타입 선언 시 차이점을 숙지할 것

```typescript
function add1(x: number, y: number): number {
  return x + y;
} // fuction 일 때는 : 뒤에 타입이 나옴
const add2: (x: number, y: number) => number = (x, y) => x + y; // 화살표 함수 일 떄는 => 뒤에 타입이 나옴
```

- : 뒷부분, as 뒷부분, <> 부분, interface, type, function 일부를 제외하면 자바스크립트와 동일. 제외하고 생각하는 연습을 초반에 해야 함

```typescript
const obj: { lat: number; lon: number } = { lat: 37.5, lon: 127.5 };
const obj = { lat: 37.5, lon: 127.5 };

const a = document.querySelector('#root') as HTMLDivElement;
const a = document.querySelector('#root');

function add<T>(x: T, y: T): T {
  return x + y;
}
function add(x, y) {
  return x + y;
}

interface A {}
type A = {};
```

- 함수 type alias 하는 방법

```typescript
type Add3 = (x: number, y: number) => number;
const add3: Add3 = (x, y) => x + y;

/* 함수 type interface */
interface Add4 {
  (x: number, y: number): number;
}
const add4: Add4 = (x, y) => x + y;
```

- 자바스크립트에 비해서 자유도가 확 줄어듦(ex: 변수에 문자열을 넣었다가 숫자로 바꾸는 등의 행동 어려워짐)

```typescript
let x = 5;
x = 'hello';
```

- any를 최대한 쓰지 않는 것을 목표로 할 것.
- never, unknown, any 타입 주의하기. any는 최대한 피하고 쓰더라도 나중에 꼭 제대로 타이핑하기.
- [never 설명글](https://ui.toast.com/weekly-pick/ko_20220323)
- 빈배열을 조심하라 -> never[]라는 타입이 들어옴
  - never라는 타입이 뜨면 일반적인 타입을 넣을 수 없다.
  - 따라서 타이핑 지정을 무조건 해줘야함

```typescript
try {
  const array = []; // noImplicitAny가 false일 때
  array[0];
} catch (error) {
  error;
}
```

- 최대한 !대신 if를 쓸 것
  - ! : null이나 undefined가 아님을 보증하는 방식
  - 보통 TypeScript는 element | null로 타입을 잡아줌 -> 모든 가능성을 고려해줌 -> 만약 head가 있는 것이 무조건 확실하다 싶으면 뒤에 느낌표를 넣으면 된다.
  - **근데 사실 비추 -> 이 세상에 "절대"는 없다.**

```typescript
const head = document.querySelector('#head')!; // 비추
console.log(head);

const head = document.querySelector('#head');
if (head) {
  // head
  console.log(head);
}
```

- string과 String은 다름. 소문자로 하는 것 기억하기
- String은 래퍼 개체이다. String은 언제 쓰냐면 new String();으로 쓸 때 사용한다. 그러나 실제로 잘 사용하지 않음.

```typescript
const a: string = 'hello';
const b: String = 'hell';
```

![image](https://github.com/Hayeong8957/Learn_TS/assets/70371342/38fd3559-c312-4e72-ae77-aaae5c19fb34)

- 템플릿 리터럴 타입이 존재(유니언 등 사용 가능)
- 템플릿 리터럴 변수에 타입 넣어도 됨. 타입의 값이 그대로 들어가게 됨.

```typescript
type World = 'world' | 'hell';

//type Greeting = 'hello world'
type Greeting = 'hello ${World}'; // -> 'hello world'

// 현실적인 응용법은 다음과 같다.
const a: Greeting = 'hello world'; // 이 시점에서 타입을 정교하게 추론해줌
```

- `type World = ‘world’ | ‘hell’ ;` union으로 두 타입으로 지정이 되었고, 템플릿 리터럴 타입을 선언하고(Greeting), 해당 템플릿 리터럴 타입을 타입으로 지정했을 경우, 타입을 정교하게 추천해준다.
  ![image](https://github.com/Hayeong8957/Learn_TS/assets/70371342/ec226a6c-7226-48ee-816b-b62c14bc7beb)

- 배열, rest, 튜플 문법

```typescript
/* 배열 타입 */
let arr: string[] = [];
let arr2: Array<string> = [];

/* rest 타입 */
function rest(...args: string[]) {}

function rest(...args: string[]) {
  console.log(args); // ["1", "2", "3"]
}

rest('1', '2', '3');

function rest2(a: number, ...args: string[]) {
  console.log(a, args); // 1, ["1", "2", "3"]
}

rest2(1, '1', '2', '3');

/* 튜플 */
const tuple: [string, number] = ['1', 1]; // 타입 요소 갯수가 정해져 있으면
tuple[2] = 'hello'; // 이렇게 넣었을 때 에러가 남 -> 현재 튜플 요소는 2개밖에 없는데 3번째 요소에 넣으려고 하다보니 에러가 남
tuple.push('hello'); // 튜플인데 push가 가능함 -> 위에 코드로 요소를 넣는 건 안되는데, 현재 코드로 push해서 3번째 요소에 넣는 건 에러메세지가 안남 (사소한 오류)
```

- enum, keyof, typeof

```typescript
const enum EDirection {
  Up,
  Down,
  Left,
  Right,
}

const ODirection = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
} as const;

EDirection.Up;

(enum member) EDirection.Up = 0

ODirection.Up;

(property) Up: 0

// Using the enum as a parameter
function walk(dir: EDirection) {}

// It requires an extra line to pull out the keys
type Direction = typeof ODirection[keyof typeof ODirection];
function run(dir: Direction) {}

walk(EDirection.Left);
run(ODirection.Right);
```
