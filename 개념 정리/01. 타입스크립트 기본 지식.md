# 기본 지식

## 메인 룰

- **TypeScript는 최종적으로 JavaScript로 변환**된다. 순전한 TypeScript코드를 돌릴 수 있는 것은 deno이나 대중화되지가 않았음. 브라우저, 노드는 모두 js파일을 실행한다.
- **TypeScript는 언어이자 컴파일러(tsc)이다.** 컴파일러는 ts코드를 js로 바꿔준다.
- **tsc는 tsconfig.json(`tsc --init` 시 생성)에 따라 ts 코드를 js(tsc 시 생성)로 바꿔준다.** 인풋인 ts와 아웃풋인 js 모두에 영향을 끼치므로 tsconfig.json 설정을 반드시 봐야한다.
  - 단순히 타입 검사만 하고 싶다면 **`tsc --noEmit`** 하면 된다.
  - 개인 의견: tsconfig.json에서 그냥 **`exModuleInterop: true, strict: true`** 두 개만 주로 켜놓는 편. `strict: true`가 핵심임
  - `allowJs: true` -> Javascript랑 TypeScript를 둘 다 쓸 수 있다.
  - `"target": "es2016"` -> 우리의 코드를 es6로 바꿔준다.
  - `"module": "commonJs"` -> NodeJS exprots 시스템을 사용하고 싶으면 이렇게 작성.
  - `"forceConsistentCasingInFileNames": true,` -> import해올 때 대소문자 꼭 지켜서 import 해오게
  - `"skipLibCheck": true` -> 다른 패키지들 다운 받아 사용할 때(.d.ts) 그런 패키지들 타입 컴파일 건너뛰게
- ts 파일을 실행하는 게 아니라 결과물인 js를 실행해야 한다.
- 에디터가 필수가 됨. VS code나 웹스톰 반드시 필요. 메모장으로 코딩 불가능한 지경에 이름.

## ts 문법

- 기본적으로 변수, 속성, 매개변수, 리턴값에 타입이 붙었다고 생각하면 됨.
- 타입들이 지워져도 잘 돌아가는 올바른 자바스크립트 문법이어야한다.

```typescript
const a: number = 5;
function add(x: number, y: number): number {
  return x + y;
}
const add: (x: number, y: number) => number = (x, y) => x + y;
const obj: { lat: number; lon: number } = { lat: 37.5, lon: 127.5 };
```

- string과 String은 다름. 소문자로 하는 것 기억하기

```typescript
const a: string = 'hello';
const b: String = 'hell';
```

- 특수한 타입 {} (null과 undefined가 아닌 모든 타입)

```typescript
const z: {} = 5;
```

- ts가 추론해주는 타입이 있는데 이런건 그냥 그대로 사용하면 됨. ts가 추론하지 못하는 경우에만 직접 타이핑할 것.
- 타입은 최대한 정확하게 하는 것이 중요하다. 추론이 정확하면 추론에 맡기고 타입은 최대한 좁게 정할 것.

```typescript
const a = 5; // 5라고 타입 추론하고 있는 것을 건드려 굳이 number라는 타입으로 더 부정확하게 만들 필요가 없다는 뜻
const b = '3';
const c = a + b;
function add(x: number, y: number) {
  return x + y;
}
```

- 타입 자리에 아예 고정된 원시값을 넣을 수 있음
- const는 바뀔 일이 없는데, 굳이 타입을 정할 필요가 없음. 타입을 최대한 정확하게 잡는 것이 좋음

```typescript
const f: 5 = 5;
const g: true = true;
const h: false = ture; /* 에러남 */
```

- function과 화살표 함수의 타입 선언 시 차이점을 숙지할 것

```typescript
function add1(x: number, y: number): number {
  return x + y;
} // fuction 일 때는 : 뒤에 타입이 나옴
const add2: (x: number, y: number) => number = (x, y) => x + y; // 화살표 함수 일 떄는 => 뒤에 타입이 나옴
```

- : 뒷부분, as 뒷부분, <> 부분, interface, type, function 일부를 제외하면 자바스크립트와 동일. 제외하고 생각하는 연습을 초반에 해야 함

```typescript
const obj: { lat: number; lon: number } = { lat: 37.5, lon: 127.5 };
const obj = { lat: 37.5, lon: 127.5 };

const a = document.querySelector('#root') as HTMLDivElement;
const a = document.querySelector('#root');

function add<T>(x: T, y: T): T {
  return x + y;
}
function add(x, y) {
  return x + y;
}

interface A {}
type A = {};
```

- 함수 type alias 하는 방법

```typescript
type Add3 = (x: number, y: number) => number;
const add3: Add3 = (x, y) => x + y;

/* 함수 type interface */
interface Add4 {
  (x: number, y: number): number;
}
const add4: Add4 = (x, y) => x + y;
```

- 자바스크립트에 비해서 자유도가 확 줄어듦(ex: 변수에 문자열을 넣었다가 숫자로 바꾸는 등의 행동 어려워짐)

```typescript
let x = 5;
x = 'hello';
```

- any를 최대한 쓰지 않는 것을 목표로 할 것.
- never, unknown, any 타입 주의하기. any는 최대한 피하고 쓰더라도 나중에 꼭 제대로 타이핑하기.
- [never 설명글](https://ui.toast.com/weekly-pick/ko_20220323)
- 빈배열을 조심하라 -> never[]라는 타입이 들어옴
  - never라는 타입이 뜨면 일반적인 타입을 넣을 수 없다.
  - 따라서 타이핑 지정을 무조건 해줘야함

```typescript
try {
  const array = []; // noImplicitAny가 false일 때
  array[0];
} catch (error) {
  error;
}
```

- 최대한 !대신 if를 쓸 것
  - ! : null이나 undefined가 아님을 보증하는 방식
  - 보통 TypeScript는 element | null로 타입을 잡아줌 -> 모든 가능성을 고려해줌 -> 만약 head가 있는 것이 무조건 확실하다 싶으면 뒤에 느낌표를 넣으면 된다.
  - **근데 사실 비추 -> 이 세상에 "절대"는 없다.**

```typescript
const head = document.querySelector('#head')!; // 비추
console.log(head);

const head = document.querySelector('#head');
if (head) {
  // head
  console.log(head);
}
```

- string과 String은 다름. 소문자로 하는 것 기억하기
- String은 래퍼 개체이다. String은 언제 쓰냐면 new String();으로 쓸 때 사용한다. 그러나 실제로 잘 사용하지 않음.

```typescript
const a: string = 'hello';
const b: String = 'hell';
```

![image](https://github.com/Hayeong8957/Learn_TS/assets/70371342/38fd3559-c312-4e72-ae77-aaae5c19fb34)

- 템플릿 리터럴 타입이 존재(유니언 등 사용 가능)
- 템플릿 리터럴 변수에 타입 넣어도 됨. 타입의 값이 그대로 들어가게 됨.

```typescript
type World = 'world' | 'hell';

//type Greeting = 'hello world'
type Greeting = 'hello ${World}'; // -> 'hello world'

// 현실적인 응용법은 다음과 같다.
const a: Greeting = 'hello world'; // 이 시점에서 타입을 정교하게 추론해줌
```

- `type World = ‘world’ | ‘hell’ ;` union으로 두 타입으로 지정이 되었고, 템플릿 리터럴 타입을 선언하고(Greeting), 해당 템플릿 리터럴 타입을 타입으로 지정했을 경우, 타입을 정교하게 추천해준다.
  ![image](https://github.com/Hayeong8957/Learn_TS/assets/70371342/ec226a6c-7226-48ee-816b-b62c14bc7beb)

- 배열, rest, 튜플 문법

```typescript
/* 배열 타입 */
let arr: string[] = [];
let arr2: Array<string> = [];

/* rest 타입 */
function rest(...args: string[]) {}

function rest(...args: string[]) {
  console.log(args); // ["1", "2", "3"]
}

rest('1', '2', '3');

function rest2(a: number, ...args: string[]) {
  console.log(a, args); // 1, ["1", "2", "3"]
}

rest2(1, '1', '2', '3');

/* 튜플 */
const tuple: [string, number] = ['1', 1]; // 타입 요소 갯수가 정해져 있으면
tuple[2] = 'hello'; // 이렇게 넣었을 때 에러가 남 -> 현재 튜플 요소는 2개밖에 없는데 3번째 요소에 넣으려고 하다보니 에러가 남
tuple.push('hello'); // 튜플인데 push가 가능함 -> 위에 코드로 요소를 넣는 건 안되는데, 현재 코드로 push해서 3번째 요소에 넣는 건 에러메세지가 안남 (사소한 오류)
```

- enum, keyof, typeof
- enum : 여러개의 변수들을 하나로 묶고 싶을 때 사용 -> 개인적으로 일반 객체 씀(by. 제로초)
- keyof : 객체의 키들만 꺼내오고 싶을 때 사용
- typeof : 값을 타입으로 쓰고 싶을 때 사용

```typescript
const enum EDirection {
  Up,
  Down,
  Left,
  Right,
}
// enum은 자바스크립트에서 사라짐 -> 안남아있게 하고 싶다. -> enum 사용

const ODirection = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
};
// -> 현재는 추론이 다 number로 되어있음

// as const 를 붙이면 난 이 속성들을 상수로 쓰겠다 -> 정확하게 타이핑해줌. -> readonly까지 정확하게 고정
const ODirection = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
} as const;
// 객체는 자바스크립트에 남아있음 -> 남아있게 하고 싶다. -> 객체 사용
// 남겨야할지 안 남겨야할지 고민 -> 남기는 걸 추천

EDirection.Up;

(enum member) EDirection.Up = 0

ODirection.Up;

(property) Up: 0

// Using the enum as a parameter
// enum은 직접 타입으로도 쓸 수 있다.
function walk(dir: EDirection) {} // dir은 4개중(Up, Down, Left, Right) 하나여야 한다.

// It requires an extra line to pull out the keys
type Direction = typeof ODirection[keyof typeof ODirection];
function run(dir: Direction) {}

const obj = {a: '123', b: 'hello', c: 'world'} as const;
// 객체의 키값만 가져와 타입으로 설정
type Key = keyof typeof obj;              // type Key = "a" | "b" | "c"
// 객체의 값만 가져와 타입으로 설정
type Key2 = typeof obj[keyof typeof obj]; // type Key2 = "123" | "hello" | "world"
// obj는 자바스크립트 값임 -> 자바스크립트 값은 타입으로 쓸 수 없음 -> 타입으로 쓰고 싶으면 typeof를 붙여줌 -> 거기에 keyof를 하면 "a", "b", "c"를 뽑아낸다. -> 그리고 그걸 Key라는 타입으로 만듦

walk(EDirection.Left); // function walk(dir: EDirection) {}
run(ODirection.Right); // function run(dir: Direction): void
```

- 객체 타이핑: type과 interface 구분하기
- 둘 중에 뭐가 낫냐하면 간단하게 하고 싶으면 type을 쓰고, interface는 상속과 구현하는 개념이 포함되어있음 -> 나중에 객체지향 프로그래밍을 하고 싶으면 interface를 사용하는 것이 좋음.
  - type으로도 객체지향 구현이 가능하나, interface문법이 문법적으로 지원을 많이 해줌.
    [interface vs type 비교](https://yceffort.kr/2021/03/typescript-interface-vs-type)

```typescript
type A = { a: string }; // A라는 타입을 정의해서
const a: A = { a: 'hello' }; // 여기에 욱여 넣음
// const a: { a: string } = { a: 'hello' }; // 이렇게 바로 넣어도 무방

interface B {
  a: string;
}
const b: B = { a: 'hello' };
```

```typescript
type Animal = { breath: true };
type Poyouryu = Animal & { breed: true };
type Human = Poyouryu & { think: true };

const hayeong: Human = { breath: true, breed: true, think: true };

interface Animal2 {
  breath: true;
}
interface Poyouryu2 extends Animal2 {
  breed: true;
}
interface Human2 extends Poyouryu2 {
  think: true;
}
const hayeon2: Human2 = { breath: true, breed: true, think: true };

// type의 좋은 점은 간단하게 쓸 수 있고
// interface는 타입처럼 욱여넣을 수 없기 때문에 extends확장이라는 개념이 명확함
```

- union, intersection
- union(|) : 또는 -> 타입 추론이 제대로 안된다. -> 모든 경우를 다 고려하게 됨
- intersection(&) : 둘 다 -> 객체에서 사용 가능

```typescript
// error: '+' 연산자를 'string | number' 및 'string | number' 형식에 적용할 수 없습니다.ts(2365)
// typescript를 할 때 처음 type을 잘 짜놔야함, 안그러면 줄줄이 다 꼬임
function add(x: string | number, y: string | number): string | number {
  return x + y;
}
add(1, 2);
add('1', '2');
add(1, '2');

type A = {
  a: string;
};
type B = {
  b: string;
};

const abab1: A | B = { a: 'hello', b: 'world' }; // A 또는 B -> A도 만족하고 B도 만족하기에 됨 -> A와 B 둘 중에 하나만 있으면 만족
const abab2: A | B = { a: 'hello' }; // 하나를 지워도 된다.

const baba1: A & B = { a: 'hello', b: 'world' }; // A 와 B 둘 다 만족시켜야 함 -> 모든 속성이 다 있어야 함
const baba2: A & B = { a: 'hello' }; // A 와 B 둘 다 만족시켜야 함 -> error
```

- 선언적 확장 : interface끼리는 서로 합쳐짐(같은 이름으로 선언하면 타입이 합쳐짐)
- type은 새로운 속성을 추가하기 위해 다시 같은 이름으로 선언할 수 없지만, interface는 항상 선언적 확장이 가능
- 라이브러리들이 대부분 type이 아니라 interface로 만들어짐 -> 라이브러리 타입을 같은 이름으로 추가만 하면 됨

```typescript
interface A {
  a: string;
}
interface A {
  b: string;
}
const obj1: A = { a: 'hello', b: 'world' };

type B = { a: string };
type B = { b: string };
const obj2: B = { a: 'hello', b: 'world' };
```

- 타입을 집합으로 생각하자(좁은 타입과 넓은 타입)
  - 밴다이어그램으로 생각하면 쉽다는 뜻
  - 큰 타입에 작은 타입을 넣으려는 시도, 작은 타입에 큰 타입을 넣으려는 시도가 발생할 수 있다.
  - 작은 타입이란, 더 구체적인 타입을 의미

```typescript
type AAA = string | number; // 이게 더 넓은 타입 -> 합집합
type BBB = string;
// 여기서 룰은 좁 -> 넓으로 대입이 가능, 넓 -> 좁 대입 불가능
// never -> 공집합, any -> 전체집합 느낌

type BBB2 = string;
type CCC = string & number; // 이게 더 좁은 타입

// 객체는 상세할수록 타입이 좁다고 생각 -> 구체적일수록 타입이 좁음
type Aobj = { name: string };
type Bobj = { age: number };
type Cobj = { name: string; age: number };
// type Cobj = Aobj & Bobj이거랑 위의 코드랑 같음

type ABObj = Aobj | Bobj; // 합집합으로 만듦 -> 타입이 넓음

type Cobj2 = Aobj & Bobj;
const ab: ABObj = { name: 'hayeong', age: 23 };
const ab2: ABObj = { name: 'hayeong' };
const ab3: ABObj = ab; // 좁은 타입을 넓은 타입에 넣는 건 잘 됨

const c2: Cobj2 = { name: 'hayeong', age: 23 };
const c3: Cobj = ab2; // 넓은 타입을 좁은 타입에 넣으려다 보니 에러: 'age' 속성이 'Aobj' 형식에 없지만 'Cobj' 형식에서 필수입니다.ts(2741)

const c4: Cobj = { name: 'hayeong', age: 23, married: false };
// Cobj가 우항보다 더 넓은 타입인데, 에러가 나고 있다.
// error: 개체 리터럴은 알려진 속성만 지정할 수 있으며 'Cobj' 형식에 'married'이(가) 없습니다.ts(2322)
```

- 객체 리터럴은 잉여 속성 검사가 있음
- 타입에 선언된 속성 외에 속성이 있는지 체크 -> 객체 리터럴에서만 동작한다. -> 그래서 엄격한 객체 리터럴 체크라고도 불린다.

```typescript
// 타입 붙여준 변수에다 직접 객체 리터럴을 넣으면 에러가 남
type A = { hello: string };
const a: A = { hello: 'world', why: 'error' }; // error:  개체 리터럴은 알려진 속성만 지정할 수 있으며 'A' 형식에 'hello'이(가) 없습니다.ts(2322)

// 중간에 다른 변수를 껴서 대입하면 에러가 안 남
const b = { hello: 'world', why: 'error' }; // 해당 객체를 변수로 빼주고
const c: A = b; // 대입하면 에러 사라짐
```

- void 타입은 return값을 사용하지 안 겠다는 뜻(메서드나 매개변수에서는 리턴값 사용 가능, but 조심해야 함)
- void는 undefined랑 다르다.
- void func 선언 시 리턴값이 void인 것 vs 메서드로 선언할 때 void vs 매개변수가 void가 들어간 것 세 가지 모두 다르다.

```typescript
// void 타입이라는 것은 리턴값이 없는 함수
// 대신 return undefined는 가능, return null은 안됨
// 리턴값이 아예 없거나 단순히 return;만 있는 함수
function afunc(): void {
  // function afunc(): void
  return;
}

const afunc2 = afunc(); // const afunc2: void

interface Human3 {
  talk: () => void;
}

const human: Human3 = {
  talk() {
    return 'abc'; // 근데 여기서는 에러가 안남!?
  },
};

// 📌 void를 세 가지로 기억하자.
// 1. void func 선언 시 리턴값이 void인 것
function bfunc(): void {
  return;
}
// 함수의 직접적인 리턴값이 void인 경우에만 return 값이 들어가면 안됨.

// 2. 메서드로 선언할 때 void
interface Human4 {
  talk: () => void;
}
// 리턴값이 있어도 됨
const human2: Human4 = {
  talk() {
    return 'abc';
  },
};

const human3 = human2.talk();
// 우리는 이것이 'abc'값을 뱉어낼 것이라 생각하지만
// 애석하게도 메서드의 void는 리턴이 무엇이든 무시를 하기에
// human3의 타입도 void이다.
// 애초에 리턴이 void면 리턴값을 넣지 않는 게 좋음.

// 3. 매개변수가 void가 들어간 것
// 함수 또는 메서드의 리턴값을 사용하지 않겠다. -> 리턴값이 없다. -> 리턴값이 뭐든 간에 사용하지 않겠다는 의미
function cfunc(callback: () => void): void {}
// 리턴값이 있어도 됨
cfunc(() => {
  return 3;
});
```

- void 예시

```typescript
// 예시
// 함수 선언부
// function forEach(arr: number[], callback: (el: number) => undefined): void;
function forEach(arr: number[], callback: (el: number) => void): void;
// 함수 구현부
function forEach() {}
// 함수 구현부를 만들기 싫을 때 declare를 선언하면 됨 -> 에러가 사라지지만, 자바스크립트로 면환하면 사라짐
declare function forEach2(
  arr: number[],
  callback: (el: number) => undefined,
): void;

let target: number[] = [];
forEach([1, 2, 3], (el) => target.push(el)); // error: 'number' 형식은 'undefined' 형식에 할당할 수 없습니다.ts(2322)
// 에러나는 이유 : push는 리턴값이 number, 해당 함수는 콜백 함수
// function forEach 콜백의 리턴값을 number로 해주면 됨
// + void로 해도 에러가 안남 => 매개변수에서 쓰이는 void는 실제 리턴값이 뭐든 상관하지 않겠다.
// return 값을 없애도 쓸 수 있게 함

// void냐 아니냐에 따라 함수 표현이 제한이 됨
// 아래 둘 다 정상적인 코드이다. 만약 위의 forEach 콜백 리턴이 void가 아니고 undefined라면 아래와 같은 에러가 나온다.
forEach([1, 2, 3], (el) => {
  target.push(el); // number형식은 undefined형식에 할당 X
});
forEach([1, 2, 3], (el) => target.push(el)); // void형식은 undefined형식에 할당 X

interface A {
  talk: () => void;
}
const a: A = {
  talk() {
    return 3;
  },
};

const b = a.talk(); // 3을 무시하기에 void타입을 가지고 있음
const b = a.talk() as unknown as number; // 이런식으로 리턴값을 강제로 바꿀 수 있음 1 => 리턴값 바꿀 때 아래방식보다 이걸 더 추천
const b = <number>(<unknown>a.talk()); // 이런식으로 리턴값을 강제로 바꿀 수 있음 2
```

- 타입만 선언하고 싶을 때 declare(구현은 다른 파일에 있어야 함)
- '이거 내가 다른 곳에서 선언했을음 보증해, 내가 책임질 수 있어'이럴 때 타입 선언만 해두는 식으로 사용
- 외부에서 만들어진 애들 타입 선언하는 declare

```typescript
declare const a: string;
declare function a(x: number): number;
declare class A {}

// 추후 declare module, declare global, declare namespace도 배움
```

- unknown, any
- any를 쓸 바에는 unknown을 쓴다고 원칙적으로 기억
  - any문제점 : 타입 검사를 포기해버림
  - unknown: 알 수 없는 형식이라 에러가 뜸 -> 우리가 직접 타입을 정해줘야함 -> 정해진 타입을 쓸 수 있게 => 지금 당장은 내가 타입을 모르겠을 때 쓰는 것

```typescript
interface ATalk {
  talk: () => void;
}
const atalk: ATalk = {
  talk() {
    return 3;
  },
};

const btalk: unknown = atalk.talk();
(btalk as ATalk).talk();

// unknown이 나오는 가장 흔한 경우
// Error은 타입스크립트에서 제공하는 기본 에러 타입.
// 에러는 우리가 대비하지 못한 뜬금없는 에러가 나오기에
// 나중에 우리가 에러의 타입이 뭔지 직접 지정해야함
// axios -> AxiosError
try {
} catch (error) {
  // var error: unknown
  (error as Error).message; // 이런식으로 만들어줘야함
}
```

- 타입간 대입 가능 표

  - 초록색 체크도 다 X라고 생각 -> strict true가 아닐 경우의 가능
    ![image](https://github.com/ZeroCho/ts-all-in-one/assets/70371342/92736343-94d0-4374-b45a-a0d95d2b1ca4)

- 타입 가드
- if 조건절에 type을 명확하게 지정하여 타입 지정하는 방법
- class인 경우 instanceof 연산자도 가능!

```typescript
// 아래 코드는 정상적으로 작동
function numOrStr(a: number | string) {
  if (typeof a === 'string') {
    a.split(',');
  } else {
    a.toFixed(1);
  }
}
numOrStr('123');
numOrStr(1);

// 아래 코드는 에러남
// a가 string일 가능성도 있기 때문에 경고를 띄워줌
// 에러메세지가 10줄 넘어가는 경우가 있는데, 결국에 마지막줄만 보면 됨
function numOrStr(a: number | string) {
  a.toFixed(1); // 'string | number' 형식에 'toFixed' 속성이 없습니다. 'string' 형식에 'toFixed' 속성이 없습니다.ts(2339)
}

(a as number).toFixed(1); // 이런식으로 타입을 변경하려고 시도할 수 있으나, unknown일 때 빼고 as 사용은 지양.

// 타입스크립트는 배열도 구분할 수 있다.
function numOrNumArr(a: number | number[]) {
  if (Array.isArray(a)) {
    // 배열인지 아닌지 구별 -> Array.isArray(구별할 배열)
    a.slice(1);
  } else {
    // number
    a.toFixed(1);
  }
}

// class 타입 가드
// class 명 자체가 타입 자리에 올 수 있다.
// 대신 그 class를 의미하는 게 아니고 인스턴스를 의미하는 것
class AClass {
  aaa() {}
}

class BClass {
  bbb() {}
}

function AOrB(param: AClass | BClass) {
  if (param instanceof AClass) {
    param.aaa();
  }
}

// AOrB(AClass); // 클래스 자체가 아니라 인스턴스를 의미하기에 바로 그 클래스를 넣으면 안됨
AOrB(new AClass()); // 이렇게 인스턴스를 넣어줘야함

// 객체 타입 가드
// 여러 객체를 작성할 때 객체에 라벨을 달아주는 것처럼 type을 작성하는 습관을 들이는 것이 좋음.
// type이 없다면 특징을 찾아서 in 연산자로 찾아낼 수 있게끔
type B = { type: 'b'; bbb: string };
type C = { type: 'c'; ccc: string };
type D = { type: 'd'; ddd: string };
type A = B | C | D;

function typeCheck(a: A) {
  // 안의 속성만으로도 구별을 해준다.
  if (a.type === 'b') {
    // B
    a.bbb;
  } else if (a.type === 'c') {
    // C
    a.ccc;
  } else {
    // D
    a.ddd;
  }
}

// 객체의 키로 구별 가능 -> in 연산자 사용
function typeCheck(a: A) {
  if ('bbb' in a) {
    // B
    a.type;
  } else if ('ccc' in a) {
    // C
    a.ccc;
  } else {
    // D
    a.ddd;
  }
}

/* 커스텀 타입 가드 */
interface Cat {
  meow: number;
}
interface Dog {
  bow: number;
}

// 리턴값에 is가 들어가면 커스텀 타입 가드이다.
// 커스텀 타입 가드 함수는 어떨 때 쓰냐?
// if문 안에 써서 타입스크립트에게 정확한 타입이 뭔지 알려주는 것
// 대신 타입 판별은 직접 코딩해야함.
function catOrDog(a: Cat | Dog): a is Dog {
  // 타입 판별을 여러분이 직접 만드세요.
  // 강아지려면
  if ((a as Cat).meow) {
    return false; // meow 속성이 없어야한다.
  }
  return true;
}

// 타입을 구분해주는 커스텀 함수를 여러분이 직접 만들 수 있어요.
function pet(a: Cat | Dog) {
  if (catOrDog(a)) {
    console.log(a.bow); // a가 Dog라는 것을 밝혀냄
  }
  if ('meow' in a) {
    console.log(a.meow);
  }
}

// Promise 예제

const isRejected = (
  input: PromiseSettledResult<unknown>,
): input is PromiseRejectedResult => {
  // PromiseSettledResult를 PromiseRejectedResult로 타입 가드
  return input.status === 'rejected';
};

const isFulfilled = <T>(
  input: PromiseSettledResult<T>,
): input is PromiseFulfilledResult<T> => {
  // PromiseSettledResult를 PromiseFulfilledResult로 타입 가드
  return input.status === 'fulfilled';
};

// Promise 를 실행하면 pending상태에서 settled가 된다.
// settled에는 resolved(then)와 rejected(catch)가 있다.
// 성공했든 실패했든 일단 settled는 맞음
// PromiseSettledResult안에는 PromiseRejectedResult와 PromiseFulfilledResult가 있다.
const promises = await Promise.allSettled([
  Promise.resolve('a'),
  Promise.resolve('b'),
]);

// 우리는 정확하게 성공한 것만 구별하고 싶다.
const success = promises.filter(isFulfilled);
// 우리는 정확하게 여기서 에러들만 구별하고 싶다.
const errors = promises.filter(isRejected);

export { success, errors };
```

- {}, Object, unknown
- {} , Object : 모든 타입, 모양이 객체라 착각하면 안된다.(null과 undefined 제외)
- object: 실제 객체 타입, 객체만 받을 수 있다.
- unknown = {} | null | undefined

```typescript
// 4.8 ver update
// {} , Object : 모든 타입, 모양이 객체라 착각하면 안된다.(null과 undefined 제외)
// object: 실제 객체 타입, 객체만 받을 수 있다.
const x: {} = 'hello'; // 문자열도 대입이 된다.
const y: Object = 'hi';
// const x2: object = 'hi'; // error
const x2: object = { hi: 'world' };
const y2: object = { hello: 'world' };
const z: unknown = 'hi';

// unknown타입도 모든 값을 다 받을 수 있는데 any보다 좀 더 낫다고 말했었다.
// 이번에 나온게 unknown = {} | null | undefined
if (z) {
  z; // unknown인 변수를 if문에 넣으면 그대로 unknown이 나왔었다.
  // 근데 지금은 const z: {}로 타입이 나오게 된다.
  // if에 들어가면 null과 undefined가 걸러져서 {}가 나오게 되는 것.
} else {
  // 여기에 null, undefined가 들어가짐
}
```

- readonly : 읽기 전용 속성
- 우리가 실수로 바꾸는 것을 강제로 금지

```typescript
interface A {
  readonly a: string;
  b: string;
}

const aA: A = {a: 'hello', b: 'world'};
// aA.a = '123'; // error: 읽기 전용 속성이므로 'a'에 할당할 수 없습니다.ts(2540)
// readonly 를 사용해서 우리가 실수로 바꾸는 것을 강제로 금지

```

- 인덱스드 시그니처, mapped type
```typescript
/* 인덱스드 시그니처 */
// ex) 어떤 키든 상관없이, 모든 value의 type이 다 문자였으면 좋겠다
// type A ={
//   a:string, b:string, c:string, d:string, e:string //...
// }
type A ={
 [key: string]: string
}
// number도 똑같이 동작함

/* mapped type */
// key type을 좁힐 수 있음
// interface로는 또는이 안됨 |를 쓰려면 type을 써야함
type BKey = 'Human' | 'Mammal' | 'Animal'; 
type B = {[key in BKey]: number};
const b: B = {
  Human: 123, Mammal: 5, Animal: 7 // 이런식으로 제한을 걸어줄 수 있다.
}
// 최대한 정확한 타입을 주는 것이 좋음
```

- class에 private, protected 추가됨

```typescript
class B implements A {
  private a: string;
  protected b: string;
}
class C extends B {}
new C().a;
new C().b;
```
